---
layout: post

title: "数据库设计范式"

date: 2021-01-31

description: Database 设计范式

tag: [Database]

---

****

https://www.zhihu.com/question/24696366

https://www.jianshu.com/p/3e97c2a1687b

**数据库范式***（NF）

数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。

***为什么需要数据库范式***

数据的多余和不一致(data redundancy and inconsistency)

数据访问的困难(difficulty in accessing data)

数据的孤立(data isolation)

​	数据分散在不同文件中，又可能文件的格式不同，因此写新的APP来做检索适当的数据好难

数据的完整性问题(integrity problem)

原子性问题(atomicity problem)

并发访问异常(concurrent-access anomaly)

​	银行同时扣钱的时候发生错误

安全性问题(security problem)

​	并非数据库的所有用户都可以访问所有数据。

为了解决以上的问题，有了数据库设计的范式。



***数据库范式分类***

目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般来说，数据库只需满足第三范式(3NF）就行了。



**第一范式（1NF）**

> 第一范式**强调每一列都是不可分割的原子数据项。**

数据库表中不能出现重复记录，每个字段是原子性的不能再分。举一个不符合1NF的实例：

| StudentID | Name | Contact            |
| --------- | ---- | ------------------ |
| 1001      | 小张   | XZ@gmail.com,12345 |
| 1002      | 小李   | XL@gmail.com,34567 |
| 1001      | 老王   | LW@gmail.com,9999  |

问题在于最后一条记录和第一条重复（不唯一，没有主键），联系方式字段可以再分，不是原子性的。关于第一范式，每一行必须唯一，也就是每个表必须有主键，这是数据库设计的最基本要求，主要采用数值型或定长字符串表示，关于列不可再分，应该根据具体的情况来决定。如联系方式，为了开发上的便利可能就采用一个字段。



**第二范式（2NF）**

>首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 要求实体的属性**完全依赖**于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。



在谈及第二范式之前，先看一下例子

| StudentID | Name | FacultyName | DepartmentHead | CourseName | Score |
| --------- | ---- | ----------- | -------------- | ---------- | ----- |
| 1001      | 小张   | 计算机科学系      | 王大明            | 高等数学       | 95    |
| 1001      | 小张   | 计算机科学系      | 王大明            | 英语         | 87    |
| 1002      | 小李   | 计算机科学系      | 王大明            | 化学         | 77    |
| 1002      | 小李   | 计算机科学系      | 王大明            | 中国历史       | 98    |
| 1003      | 老王   | 法律系         | 张小花            | 物理         | 74    |
| 1003      | 老王   | 法律系         | 张小花            | 法学基础       | 99    |



这张表的问题

**数据冗余过大**

​	每一名学生的学号、姓名、系名、系主任被重复了

**插入异常**

​	假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 

**删除异常**

​	假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）

**修改异常**

​	假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据

**为了解决这些问题，引入几个概念，分别是函数依赖（ functional dependency), 码、非主属性(Nonprime Attribute)、与部分函数依赖(Partial dependency)  **



***函数依赖***

**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说**姓名函数依赖于学号**，写作 **学号 → 姓名**。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如：

- 系名 → 系主任
- 学号 → 系主任
- （学号，课名） → 分数

但以下函数依赖关系则不成立：

- 学号 → 课名
- 学号 → 分数
- 课名 → 系主任
- （学号，课名） → 姓名

**完全函数依赖**

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**，记作 X F→ Y。

例如：

- 学号 F→ 姓名
- （学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）

**部分函数依赖**

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y

- （学号，课名） P→ 姓名

**码**
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）

**非主属性**
包含在任何一个码中的属性成为主属性。



根据2NF的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。

第一步：找出数据表中所有的**码**。
第二步：根据第一步所得到的码，找出所有的**主属性**。
第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
第四步：查看是否存在非主属性对码的**部分函数依赖**。

Step1:

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“**完全**函数依赖”）。

![img](https://pic3.zhimg.com/80/51e2689ac9416a91800e63101bee9db7_1440w.jpg?source=1940ef5c)



Step 2:

主属性有两个：**学号 **与**课名**



Step 3：
非主属性有四个：**姓名**、**系名**、**系主任**、**分数**



Step 4:

对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名 **对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名 **对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性  对码**（学号，课名）**的部分函数依赖。



**所以这个表不符合2NF的要求**



**解决办法**：

将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫模式分解。

选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）

对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。



![img](https://pic1.zhimg.com/80/2f4b4a887f6a61674a49d03d79e3fe17_1440w.jpg?source=1940ef5c)









